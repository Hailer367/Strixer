name: Strixer - Direct CLIProxyAPI Security Scan

on:
  workflow_dispatch:
    inputs:
      decryption_password:
        description: 'Password to decrypt QWEN_TOKENS'
        required: true
        type: string
      target:
        description: 'Target to scan (URL, path, or repository)'
        required: false
        default: './'
        type: string
      prompt:
        description: 'Custom instructions for the AI agent'
        required: false
        default: ''
        type: string
      timeframe:
        description: 'Maximum runtime in minutes (10-720)'
        required: false
        default: '60'
        type: choice
        options:
          - '10'
          - '15'
          - '30'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '360'
          - '480'
          - '720'
      warning_minutes:
        description: 'Minutes before end to warn AI (1-30)'
        required: false
        default: '5'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'
      scan_mode:
        description: 'Scan mode'
        required: false
        default: 'deep'
        type: choice
        options:
          - quick
          - standard
          - deep
      model:
        description: 'AI Model to use'
        required: false
        default: 'qwen3-coder-plus'
        type: choice
        options:
          - 'qwen3-coder-plus'
          - 'qwen3-coder-flash'
          - 'qwen3-max'
          - 'qwen-plus'
          - 'qwen-turbo'
          - 'qwen2.5-coder-32b-instruct'
      reencrypt_tokens:
        description: 'Re-encrypt and update QWEN_TOKENS after scan'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      enable_dashboard:
        description: 'Enable real-time web dashboard'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  pull_request:

concurrency:
  group: strixer-scan-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  DEFAULT_TIMEFRAME: '60'
  DEFAULT_WARNING_MINUTES: '5'
  DEFAULT_SCAN_MODE: 'deep'
  CLIPROXY_PORT: '8317'
  DASHBOARD_PORT: '8080'

jobs:
  security-scan:
    name: Strixer Security Scan (Direct CLIProxyAPI)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write

    steps:
      - name: Compute timeout
        id: vars
        run: |
          set -euo pipefail
          TF="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          if ! [[ "$TF" =~ ^[0-9]+$ ]]; then
            echo "Invalid timeframe: $TF" >&2
            exit 1
          fi
          echo "timeout=$(( TF + 30 ))" >> "$GITHUB_OUTPUT"

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Decrypt Qwen Tokens
        id: decrypt
        run: |
          set -euo pipefail
          echo "::group::Decrypting Qwen tokens"
          if [ -z "${{ secrets.QWEN_TOKENS }}" ]; then
            echo "::error::QWEN_TOKENS secret is not set"
            exit 1
          fi
          mkdir -p ~/.cli-proxy-api
          cd ~/.cli-proxy-api
          echo "${{ secrets.QWEN_TOKENS }}" | base64 -d > qwen-tokens.enc
          if ! echo "${{ github.event.inputs.decryption_password }}" | openssl enc -aes-256-cbc -d -salt -pbkdf2 -in qwen-tokens.enc -out qwen-tokens.tar.gz -pass stdin 2>/dev/null; then
            echo "::error::Failed to decrypt tokens. Invalid password"
            exit 1
          fi
          tar -xzf qwen-tokens.tar.gz
          for dir in account-*/; do
            [ -d "$dir" ] && mv "$dir"qwen-*.json . 2>/dev/null || true
          done
          TOKEN_COUNT=$(find . -maxdepth 1 -name 'qwen-*.json' | wc -l)
          if [ "$TOKEN_COUNT" -eq 0 ]; then
            echo "::error::No token files found after decryption"
            exit 1
          fi
          echo "Successfully decrypted $TOKEN_COUNT Qwen account(s)"
          echo "token_count=$TOKEN_COUNT" >> "$GITHUB_OUTPUT"
          rm -f qwen-tokens.enc qwen-tokens.tar.gz
          echo "::endgroup::"

      - name: Install CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Installing CLIProxyAPI"
          git clone --depth 1 https://github.com/router-for-me/CLIProxyAPI.git /tmp/CLIProxyAPI
          cd /tmp/CLIProxyAPI
          go build -o cli-proxy-api ./cmd/server
          sudo mv cli-proxy-api /usr/local/bin/
          if ! cli-proxy-api --help >/dev/null 2>&1; then
            echo "::error::CLIProxyAPI failed to install"
            exit 1
          fi
          echo "CLIProxyAPI installed"
          echo "::endgroup::"

      - name: Install SAST Tools
        run: |
          set -euo pipefail
          echo "::group::Installing SAST Tools"
          pip install semgrep bandit trufflehog detect-secrets checkov safety pip-audit 2>/dev/null || true
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz | tar xz -C /usr/local/bin gitleaks 2>/dev/null || true
          echo "::endgroup::"

      - name: Install DAST Tools
        run: |
          set -euo pipefail
          echo "::group::Installing DAST Tools"
          sudo apt-get update -qq && sudo apt-get install -y -qq nmap nikto dnsutils whois jq curl wget unzip || true
          curl -sSfL https://github.com/projectdiscovery/nuclei/releases/download/v3.2.9/nuclei_3.2.9_linux_amd64.zip -o /tmp/nuclei.zip && unzip -q /tmp/nuclei.zip -d /usr/local/bin 2>/dev/null || true
          nuclei -update-templates 2>/dev/null || true
          curl -sSfL https://github.com/ffuf/ffuf/releases/download/v2.1.0/ffuf_2.1.0_linux_amd64.tar.gz | tar xz -C /usr/local/bin ffuf 2>/dev/null || true
          pip install sqlmap dirsearch 2>/dev/null || true
          echo "::endgroup::"

      - name: Configure CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Configuring CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cat > "$AUTH_DIR/config.yaml" << 'EOF'
          host: "127.0.0.1"
          port: 8317
          auth-dir: "~/.cli-proxy-api"
          debug: true
          logging-to-file: true
          request-retry: 5
          max-retry-interval: 60
          quota-exceeded:
            switch-project: true
            switch-preview-model: true
          routing:
            strategy: "round-robin"
          EOF
          sed -i 's/^          //' "$AUTH_DIR/config.yaml"
          echo "Configuration created:"
          cat "$AUTH_DIR/config.yaml"
          echo "::endgroup::"

      - name: Start CLIProxyAPI Server
        id: cliproxy
        run: |
          set -euo pipefail
          echo "::group::Starting CLIProxyAPI Server"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cd "$AUTH_DIR"
          
          # List token files for debugging
          echo "Token files found:"
          ls -la qwen-*.json 2>/dev/null || echo "No qwen token files found!"
          
          nohup cli-proxy-api -config config.yaml > cliproxy.log 2>&1 &
          SERVER_PID=$!
          echo "$SERVER_PID" > cliproxy.pid
          sleep 15
          
          if ! kill -0 $SERVER_PID 2>/dev/null; then
            echo "::error::CLIProxyAPI failed to start"
            cat cliproxy.log || echo "No log file"
            exit 1
          fi
          
          # Wait for server to be ready
          for i in {1..20}; do
            MODELS_RESPONSE=$(curl -s "http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1/models" 2>/dev/null || true)
            if [ -n "$MODELS_RESPONSE" ] && echo "$MODELS_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
              echo "CLIProxyAPI is ready!"
              echo "Available models:"
              echo "$MODELS_RESPONSE" | jq -r '.data[].id' 2>/dev/null | head -20 || true
              break
            fi
            echo "Waiting for CLIProxyAPI... (attempt $i/20)"
            sleep 3
          done
          
          # Show startup logs
          echo "CLIProxyAPI startup logs:"
          head -50 cliproxy.log || true
          
          ENDPOINT="http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1"
          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "pid=$SERVER_PID" >> "$GITHUB_OUTPUT"
          echo "=========================================="
          echo "CLIPROXYAPI READY (DIRECT HTTP MODE)"
          echo "Endpoint: $ENDPOINT"
          echo "Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "=========================================="
          echo "::endgroup::"

      - name: Setup Direct CLIProxyAPI Environment
        run: |
          set -euo pipefail
          echo "::group::Setting up Direct CLIProxyAPI environment (NO LiteLLM)"
          
          # Direct CLIProxyAPI mode - NO LiteLLM dependency
          echo "CLIPROXY_ENDPOINT=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "CLIPROXY_MODEL=${{ github.event.inputs.model || 'qwen3-coder-plus' }}" >> "$GITHUB_ENV"
          
          # Dummy API key for CLIProxyAPI OAuth mode
          echo "OPENAI_API_KEY=cliproxy-direct-mode" >> "$GITHUB_ENV"
          echo "OPENAI_API_BASE=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          
          # Enable direct API mode
          echo "STRIX_DIRECT_API_MODE=true" >> "$GITHUB_ENV"
          
          # Test the endpoint directly
          echo "Testing CLIProxyAPI endpoint directly..."
          MODEL_COUNT=$(curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" | jq '.data | length' 2>/dev/null || echo "0")
          echo "Available models: $MODEL_COUNT"
          
          # Test a simple completion request - THIS IS CRITICAL
          echo "Testing direct chat completion (validating Qwen token)..."
          RESPONSE=$(curl -s -X POST "${{ steps.cliproxy.outputs.endpoint }}/chat/completions" \
            -H "Content-Type: application/json" \
            -d '{
              "model": "${{ github.event.inputs.model || 'qwen3-coder-plus' }}",
              "messages": [{"role": "user", "content": "Say OK"}],
              "max_tokens": 10
            }' 2>/dev/null || echo '{"error": "connection failed"}')
          
          echo "API Response: $RESPONSE"
          
          # Check for various error conditions
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // .error' 2>/dev/null || echo "unknown")
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // .error' 2>/dev/null || echo "unknown error")
            
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  âŒ QWEN TOKEN VALIDATION FAILED                             â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  Error Code: $ERROR_CODE"
            echo "â•‘  Error Message: $ERROR_MSG"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            
            if [[ "$ERROR_CODE" == "invalid_api_key" ]] || [[ "$ERROR_MSG" == *"expired"* ]] || [[ "$ERROR_MSG" == *"invalid"* ]]; then
              echo "â•‘  ðŸ“› Your Qwen authentication token has EXPIRED or is INVALID â•‘"
              echo "â•‘                                                              â•‘"
              echo "â•‘  TO FIX THIS:                                                â•‘"
              echo "â•‘  1. Go to https://chat.qwen.ai and log in                    â•‘"
              echo "â•‘  2. Open browser DevTools (F12) â†’ Application â†’ Cookies     â•‘"
              echo "â•‘  3. Copy the new token values                                â•‘"
              echo "â•‘  4. Update your QWEN_TOKENS secret in GitHub                 â•‘"
              echo "â•‘  5. Re-run this workflow                                     â•‘"
            elif [[ "$ERROR_MSG" == *"auth_unavailable"* ]] || [[ "$ERROR_MSG" == *"no auth"* ]]; then
              echo "â•‘  ðŸ“› No valid authentication found in CLIProxyAPI             â•‘"
              echo "â•‘                                                              â•‘"
              echo "â•‘  The Qwen token files were decrypted but may be corrupted    â•‘"
              echo "â•‘  or in an unexpected format.                                 â•‘"
            else
              echo "â•‘  ðŸ“› Unknown authentication error                             â•‘"
            fi
            
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::error::Qwen token validation failed: $ERROR_MSG"
            exit 1
          fi
          
          if echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            AI_RESPONSE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  âœ… QWEN TOKEN VALIDATED SUCCESSFULLY                        â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  AI Response: $AI_RESPONSE"
            echo "â•‘  Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
            echo "â•‘  Accounts: ${{ steps.decrypt.outputs.token_count }}"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
          else
            echo "::error::Unexpected response format from CLIProxyAPI"
            echo "Response: $RESPONSE"
            exit 1
          fi
          echo "::endgroup::"

      - name: Install Strix from Source
        run: |
          set -euo pipefail
          echo "::group::Installing Strix (Direct CLIProxyAPI Mode)"
          
          # Use the already checked out repository instead of cloning again
          cp -r "$GITHUB_WORKSPACE" /tmp/strix-source
          cd /tmp/strix-source
          
          pip install -q poetry
          poetry config virtualenvs.create false
          
          # Install Strix with all dependencies
          echo "Installing Strix dependencies with Poetry..."
          if ! poetry install --no-interaction 2>&1; then
            echo "::warning::Poetry install had issues, trying with pip fallback..."
            pip install -e .
          fi
          
          # Ensure critical dependencies are installed
          echo "Verifying critical dependencies..."
          pip install jinja2 httpx tenacity requests pydantic rich docker textual xmltodict aiohttp
          
          # Verify installation
          echo "Verifying Strix installation..."
          if ! python -c "from strix.interface.main import main; print('Strix CLI loaded successfully')"; then
            echo "::error::Strix installation verification failed!"
            exit 1
          fi
          
          echo "Strix installation complete (Direct CLIProxyAPI Mode)"
          echo "::endgroup::"

      - name: Build Dashboard
        id: dashboard_build
        if: github.event.inputs.enable_dashboard == 'true'
        run: |
          echo "::group::Building Dashboard"
          cd /tmp/strix-source/strix/dashboard/frontend
          if [ ! -f "package.json" ]; then
            echo "::warning::package.json not found. Skipping dashboard build."
            echo "built=false" >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
            exit 0
          fi
          npm install --legacy-peer-deps --no-audit --no-fund 2>&1 | tail -20 || true
          npm run build 2>&1 || true
          if [ -d "dist" ] || [ -d "out" ]; then
            echo "Dashboard built successfully"
            echo "built=true" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::Dashboard build failed"
            echo "built=false" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"

      - name: Start Dashboard Server
        id: dashboard
        if: github.event.inputs.enable_dashboard == 'true' && steps.dashboard_build.outputs.built == 'true'
        env:
          STRIX_DASHBOARD_STATE_FILE: /tmp/strix_dashboard_state.json
        run: |
          echo "::group::Starting Dashboard Server"
          echo '{}' > /tmp/strix_dashboard_state.json
          chmod 666 /tmp/strix_dashboard_state.json
          cat > /tmp/start_dashboard.py << 'PYEOF'
          import sys
          sys.path.insert(0, '/tmp/strix-source')
          from strix.dashboard import start_dashboard
          import os
          import json
          config = {
              "target": os.environ.get("SCAN_TARGET", "./"),
              "timeframe": int(os.environ.get("SCAN_TIMEFRAME", "60")),
              "scan_mode": os.environ.get("SCAN_MODE", "deep"),
              "model": os.environ.get("SCAN_MODEL", "qwen3-coder-plus"),
          }
          server = start_dashboard(host="0.0.0.0", port=8080, scan_config=config)
          print(f"Dashboard running at http://localhost:8080")
          import time
          while True:
              time.sleep(60)
          PYEOF
          export SCAN_TARGET="${{ github.event.inputs.target || './' }}"
          export SCAN_TIMEFRAME="${{ github.event.inputs.timeframe || '60' }}"
          export SCAN_MODE="${{ github.event.inputs.scan_mode || 'deep' }}"
          export SCAN_MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          nohup python /tmp/start_dashboard.py > /tmp/dashboard.log 2>&1 &
          echo "$!" > /tmp/dashboard.pid
          sleep 5
          if kill -0 $(cat /tmp/dashboard.pid) 2>/dev/null; then
            echo "Dashboard started"
            echo "running=true" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::Dashboard failed to start"
            cat /tmp/dashboard.log || true
            echo "running=false" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"

      - name: Start Cloudflare Tunnel
        id: tunnel
        if: github.event.inputs.enable_dashboard == 'true' && steps.dashboard.outputs.running == 'true'
        run: |
          echo "::group::Starting Cloudflare Tunnel"
          curl -sSfL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o /usr/local/bin/cloudflared
          chmod +x /usr/local/bin/cloudflared
          nohup cloudflared tunnel --url http://localhost:${{ env.DASHBOARD_PORT }} > /tmp/tunnel.log 2>&1 &
          echo "$!" > /tmp/tunnel.pid
          sleep 10
          DASHBOARD_URL=""
          for i in {1..30}; do
            DASHBOARD_URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' /tmp/tunnel.log | head -1 || true)
            if [ -n "$DASHBOARD_URL" ]; then
              break
            fi
            sleep 2
          done
          if [ -n "$DASHBOARD_URL" ]; then
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  ðŸŒ LIVE DASHBOARD URL                                       â•‘"
            echo "â•‘  $DASHBOARD_URL"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::notice title=Dashboard Available::$DASHBOARD_URL"
            echo "url=$DASHBOARD_URL" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::Could not establish tunnel"
            echo "url=" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"

      - name: Run Strix Security Scan
        id: strix
        timeout-minutes: ${{ fromJSON(steps.vars.outputs.timeout) }}
        continue-on-error: true
        env:
          STRIXDB_TOKEN: ${{ secrets.STRIXDB_TOKEN }}
          # Direct CLIProxyAPI mode - model name without provider prefix
          STRIX_LLM: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          LLM_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          OPENAI_API_KEY: cliproxy-direct-mode
          OPENAI_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          # DIRECT CLIProxyAPI endpoint for HTTP requests
          CLIPROXY_ENDPOINT: ${{ steps.cliproxy.outputs.endpoint }}
          CLIPROXY_MODEL: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          # Direct API mode settings
          STRIX_DIRECT_API_MODE: 'true'
          STRIX_USE_HOST_NETWORK: 'true'
          STRIX_DASHBOARD_STATE_FILE: /tmp/strix_dashboard_state.json
          STRIX_SCAN_DURATION_MINUTES: ${{ github.event.inputs.timeframe || '60' }}
          PERPLEXITY_API_KEY: ${{ secrets.PERPLEXITY_API_KEY }}
          # Use custom image from this repository
          STRIX_IMAGE: ghcr.io/${{ github.repository_owner }}/strix-sandbox:latest
        run: |
          set +e
          echo "::group::Running Strix Security Scan (Direct CLIProxyAPI)"
          TARGET="${{ github.event.inputs.target || './' }}"
          TIMEFRAME="${{ github.event.inputs.timeframe || '60' }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || 'deep' }}"
          
          export STRIX_SCAN_START_TIME=$(date +%s)
          
          USER_PROMPT="${{ github.event.inputs.prompt }}"
          EXTRA_INSTRUCTIONS="You have ${TIMEFRAME} minutes. Use get_remaining_time() regularly. Multi-action mode (up to 7 actions per call) for efficiency. Load-balanced across ${{ steps.decrypt.outputs.token_count }} Qwen accounts via CLIProxyAPI."
          if [ -n "$USER_PROMPT" ]; then
            FULL_INSTRUCTIONS="${USER_PROMPT}. ${EXTRA_INSTRUCTIONS}"
          else
            FULL_INSTRUCTIONS="${EXTRA_INSTRUCTIONS}"
          fi
          
          # Print Dashboard URL prominently
          DASHBOARD_URL="${{ steps.tunnel.outputs.url }}"
          if [ -n "$DASHBOARD_URL" ]; then
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  ðŸŒ LIVE DASHBOARD URL                                       â•‘"
            echo "â•‘  $DASHBOARD_URL"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          fi
          
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘           STRIXER SECURITY SCAN STARTING                     â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Target: $TARGET"
          echo "â•‘  Timeframe: $TIMEFRAME minutes"
          echo "â•‘  Scan Mode: $SCAN_MODE"
          echo "â•‘  Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "â•‘  Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "â•‘  CLIProxyAPI Endpoint: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "â•‘  API Mode: Direct HTTP (no LiteLLM)"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Verify CLIProxyAPI is still running before starting scan
          echo "Verifying CLIProxyAPI status..."
          if ! curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" > /dev/null 2>&1; then
            echo "::warning::CLIProxyAPI may not be responding. Checking logs..."
            cat ~/.cli-proxy-api/cliproxy.log | tail -20 || true
          else
            echo "CLIProxyAPI is responding."
          fi
          
          cd /tmp/strix-source
          
          strix --target "$TARGET" --scan-mode "$SCAN_MODE" --non-interactive --instruction "$FULL_INSTRUCTIONS" 2>&1 | tee strix_output.log
          EXIT_CODE=${PIPESTATUS[0]}
          
          # Log the CLIProxyAPI status for debugging
          echo "========================================="
          echo "CLIProxyAPI Status:"
          if [ -f "$HOME/.cli-proxy-api/cliproxy.log" ]; then
            echo "Last 30 lines of CLIProxyAPI log:"
            tail -n 30 "$HOME/.cli-proxy-api/cliproxy.log"
          fi
          echo "========================================="
          
          VULN_COUNT=$(grep -ciE "vulnerability|VULNERABILITY|CVE-|critical|high.*severity" strix_output.log 2>/dev/null || echo "0")
          # Ensure VULN_COUNT is a valid number
          if ! [[ "$VULN_COUNT" =~ ^[0-9]+$ ]]; then
            VULN_COUNT="0"
          fi
          
          echo "scan_completed=true" >> "$GITHUB_OUTPUT"
          echo "vulnerabilities_found=$VULN_COUNT" >> "$GITHUB_OUTPUT"
          echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
          exit 0

      - name: Stop Dashboard and Tunnel
        if: always()
        run: |
          [ -f /tmp/tunnel.pid ] && kill $(cat /tmp/tunnel.pid) 2>/dev/null || true
          [ -f /tmp/dashboard.pid ] && kill $(cat /tmp/dashboard.pid) 2>/dev/null || true

      - name: Stop CLIProxyAPI Server
        if: always()
        run: |
          AUTH_DIR="$HOME/.cli-proxy-api"
          if [ -f "$AUTH_DIR/cliproxy.pid" ]; then
            PID=$(cat "$AUTH_DIR/cliproxy.pid")
            kill $PID 2>/dev/null || true
            wait $PID 2>/dev/null || true
            echo "CLIProxyAPI stopped (PID: $PID)"
          fi
          if [ -f "$AUTH_DIR/cliproxy.log" ]; then
            echo "=========================================="
            echo "FULL CLIProxyAPI LOGS:"
            echo "=========================================="
            cat "$AUTH_DIR/cliproxy.log"
            echo "=========================================="
          fi
          rm -rf "$AUTH_DIR"/qwen-*.json
          rm -f "$AUTH_DIR/cliproxy.pid"

      - name: Re-encrypt and Update QWEN_TOKENS
        if: always() && github.event.inputs.reencrypt_tokens == 'true'
        env:
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
          SERVER_TOKEN: ${{ secrets.SERVER_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "::group::Re-encrypting Qwen tokens"
          if [ -z "$ENCRYPTION_KEY" ]; then
            echo "::warning::ENCRYPTION_KEY not set. Skipping."
            exit 0
          fi
          if [ -z "$SERVER_TOKEN" ]; then
            echo "::warning::SERVER_TOKEN not set. Skipping."
            exit 0
          fi
          AUTH_DIR="$HOME/.cli-proxy-api"
          cd "$AUTH_DIR"
          TOKEN_COUNT=$(find . -maxdepth 1 -name 'qwen-*.json' 2>/dev/null | wc -l)
          if [ "$TOKEN_COUNT" -eq 0 ]; then
            echo "::warning::No tokens to re-encrypt"
            exit 0
          fi
          echo "Re-encrypting $TOKEN_COUNT token(s)"
          mkdir -p tokens_backup
          ACCOUNT_NUM=1
          for token_file in qwen-*.json; do
            if [ -f "$token_file" ]; then
              mkdir -p "tokens_backup/account-${ACCOUNT_NUM}"
              cp "$token_file" "tokens_backup/account-${ACCOUNT_NUM}/"
              ACCOUNT_NUM=$((ACCOUNT_NUM + 1))
            fi
          done
          cd tokens_backup && tar -czf ../qwen-tokens-new.tar.gz . && cd ..
          echo "$ENCRYPTION_KEY" | openssl enc -aes-256-cbc -salt -pbkdf2 -in qwen-tokens-new.tar.gz -out qwen-tokens-new.enc -pass stdin
          NEW_SECRET_VALUE=$(base64 -w 0 qwen-tokens-new.enc)
          KEY_RESPONSE=$(curl -s -H "Authorization: Bearer $SERVER_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$GH_REPO/actions/secrets/public-key")
          PUBLIC_KEY=$(echo "$KEY_RESPONSE" | jq -r '.key')
          KEY_ID=$(echo "$KEY_RESPONSE" | jq -r '.key_id')
          if [ -z "$PUBLIC_KEY" ] || [ "$PUBLIC_KEY" = "null" ]; then
            echo "::error::Failed to get public key"
            exit 1
          fi
          pip install pynacl -q
          echo "$NEW_SECRET_VALUE" > secret_value.txt
          export PUBLIC_KEY
          ENCRYPTED_VALUE=$(python3 -c "
          import base64, os
          from nacl import public
          pk = base64.b64decode(os.environ['PUBLIC_KEY'])
          sv = open('secret_value.txt').read().strip()
          box = public.SealedBox(public.PublicKey(pk))
          enc = box.encrypt(sv.encode('utf-8'))
          print(base64.b64encode(enc).decode('utf-8'))
          ")
          curl -s -X PUT -H "Authorization: Bearer $SERVER_TOKEN" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" "https://api.github.com/repos/$GH_REPO/actions/secrets/QWEN_TOKENS" -d "{\"encrypted_value\":\"$ENCRYPTED_VALUE\",\"key_id\":\"$KEY_ID\"}"
          echo "QWEN_TOKENS updated!"
          rm -rf tokens_backup qwen-tokens-new.tar.gz qwen-tokens-new.enc secret_value.txt
          echo "::endgroup::"

      - name: Cleanup
        if: always()
        run: |
          rm -rf "$HOME/.cli-proxy-api"/qwen-*.json "$HOME/.cli-proxy-api/cliproxy.pid" 2>/dev/null || true

      - name: Upload Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: strixer-results-${{ github.run_id }}
          path: |
            /tmp/strix-source/strix_runs/
            /tmp/strix-source/strix_output.log
            ~/.cli-proxy-api/cliproxy.log
            /tmp/dashboard.log
            /tmp/tunnel.log
          retention-days: 30

      - name: Create Security Summary
        if: always()
        run: |
          set -euo pipefail
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          VULNS="${{ steps.strix.outputs.vulnerabilities_found }}"
          TIMED_OUT="${{ steps.strix.outputs.timed_out }}"
          TOKEN_COUNT="${{ steps.decrypt.outputs.token_count }}"
          EXIT_CODE="${{ steps.strix.outputs.exit_code }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          TARGET="${{ github.event.inputs.target }}"
          DASHBOARD_URL="${{ steps.tunnel.outputs.url }}"
          
          # Determine status
          if [ "$TIMED_OUT" == "true" ]; then
            STATUS_EMOJI="â°"
            STATUS_TEXT="Scan completed (timeframe exhausted)"
          elif [ "$EXIT_CODE" == "0" ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="Scan completed successfully"
          elif [ "$EXIT_CODE" == "2" ]; then
            STATUS_EMOJI="ðŸ”´"
            STATUS_TEXT="Scan completed with vulnerabilities found"
          else
            STATUS_EMOJI="âš ï¸"
            STATUS_TEXT="Scan completed with exit code: $EXIT_CODE"
          fi
          
          # Create summary
          cat > "$GITHUB_STEP_SUMMARY" << SUMMARY_EOF
          # ðŸ¦‰ Strixer Security Scan Dashboard

          ## $STATUS_EMOJI Status: $STATUS_TEXT

          ---

          ### ðŸ“Š Scan Overview

          | Property | Value |
          |----------|-------|
          | **Target** | \`$TARGET\` |
          | **Scan Mode** | $SCAN_MODE |
          | **Model** | $MODEL |
          | **Duration** | $TIMEFRAME minutes |
          | **Qwen Accounts** | $TOKEN_COUNT (load-balanced) |
          | **API Mode** | Direct CLIProxyAPI (No LiteLLM) |
          | **Exit Code** | $EXIT_CODE |

          SUMMARY_EOF
          
          # Add dashboard info if available
          if [ -n "$DASHBOARD_URL" ]; then
            cat >> "$GITHUB_STEP_SUMMARY" << DASHEOF

          ### ðŸŒ Live Dashboard

          **[$DASHBOARD_URL]($DASHBOARD_URL)**

          DASHEOF
          fi
          
          # Add vulnerability info
          VULN_NUM=${VULNS:-0}
          cat >> "$GITHUB_STEP_SUMMARY" << FINDINGSEOF

          ### ðŸ” Findings

          FINDINGSEOF
          
          if [ "$VULN_NUM" -gt "0" ]; then
            echo "**ðŸ”´ Potential Vulnerabilities Detected: $VULN_NUM**" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> âš ï¸ Review the detailed report in the workflow artifacts." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "**ðŸŸ¢ No vulnerabilities detected in this scan.**" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          cat >> "$GITHUB_STEP_SUMMARY" << 'FEATURES_EOF'

          ---

          ### âš™ï¸ Configuration Features (Strixer)

          - âœ… Multi-Action Mode (up to 7 actions/call)
          - âœ… Qwen Token Load Balancing via CLIProxyAPI
          - âœ… **Direct HTTP API Mode (No LiteLLM)**
          - âœ… Automatic Token Refresh
          - âœ… Request Retry (5 attempts)

          ---

          *Strix AI Scanner (89pl/Strixer) - Direct CLIProxyAPI Mode*
          FEATURES_EOF
          
          echo "âœ… Security summary created"
